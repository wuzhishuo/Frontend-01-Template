# 第五周总结

## 本周的主要学习内容
  - JavaScript 结构化程序设计
  - 浏览器基本原理之HTTP

## JavaScript 结构化程序设计
  - 在JS执行之前会对执行JS所需的内置对象进行实例化，产生Realm，每个Realm里面的同一个对象不相等，比如浏览器的全局Object与iframe里面contentWindow的Object不相等

  - JS执行粒度
    - 宏任务
    - 微任务
    - 函数调用
    - 语句/声明
    - 表达式
    - 直接量/变量/this

  - JS事件循环机制
    - 宿主会一直循环等待新的JS代码执行任务，宿主每次将接收到的JS代码片段交给JS引擎执行的过程是一次宏任务，一段段要执行的JS代码就组成宏任务队列
    - 宿主按顺序从宏任务队列一个个取出任务交由JS引擎执行，一个宏任务执行完才会执行下一个宏任务，不然一直会处于阻塞
    - 由宿主API产生的任务是宏任务，比如setTimeout、宿主产生的事件
    - JS引擎在执行一段代码的过程中，可能会产生一个个新的任务，这个过程产生的任务是微任务，放在微任务队列里面
    - 目前只能通过Promise和MutationObserver产生微任务，MutationObserver是宿主API，但是产生的是微任务
    - 在一次宏任务里面产生的微任务按入队先后按顺序执行，微任务在每个宏任务的最后执行，执行完所有微任务，宏任务执行完成
    - Promise每次resolve的时候会将then里面的回调放入微任务队列

  - 分析异步代码执行顺序的步骤
    1. 分析有多少个宏任务
    2. 在每个宏任务中，分析有多少个微任务
    3. 根据调用次序，确定宏任务中的微任务执行次序
    4. 根据宏任务的触发规则和调用次序，确定宏任务的执行次序
    5. 确定整个顺序

  - 函数执行上下文
    - JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”
    - 在 ES 5中，执行上下文包括以下三部分：
      - lexical environment：词法环境，当获取变量时使用，使用let声明的变量
      - variable environment：变量环境，当声明变量时使用，使用var声明的变量
      - this value：this 值。
    - 在 ES2018 中，执行上下文包括以下部分
      - lexical environment：词法环境，当获取变量或者 this 值时使用。
      - variable environment：变量环境，当声明变量时使用。
      - code evaluation state：用于恢复代码执行位置。
      - Function：执行的任务是函数时使用，表示正在被执行的函数。
      - ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。
      - Realm：使用的基础库和内置对象实例。
      - Generator：仅生成器上下文有这个属性，表示当前生成器。
    - 函数执行的时候，JavaScript 引擎首先会在“当前的执行上下文”中查找变量，在“当前的执行上下文”找不到改变量时会在外层执行上下文继续查找，从而形成作用域链
  
## 浏览器基本原理-HTTP协议
  - 七层网络模型
    - 应用
    - 表示
    - 会话
    - 传输
    - 网络
    - 数据链路
    - 物理层

  - 前端开发工作不需要过多掌握上面的七层网络模型，要关注下面的四个方面，分别对应七层网络的某部分
    - HTTP（应用层）
    - TCP（传输层）
    - Internet（网络层）
    - 4G/5G/WIFI（数据链路层）

  - HTTP协议以文本的形式传输信息，通过换行符区分不同的信息块，分为请求和响应，采用一问一答的形式进行信息传递，必须先由客户端发起请求

  - HTTP请求头格式如下

    这里显示的其实是将\r\n显示为换行的效果，实际传输的是纯文本，每一行信息后面有\r\n换行符
    ```
    POST {PATH} /HTTP/1.1                           // 请求行: {PATH}->实际请求的路径
    Host: 127.0.0.1                                 // 请求头，从第二行开始是请求头
    Content-Type: application/x-www-form-urlencoded // 请求头
                                                    // 必须的空白换行符，将请求头与请求体分隔
    field1=aaa&code=x%3D1                           // 请求体
    ```

  - HTTP响应头格式如下

    这里显示的其实是将\r\n显示为换行的效果，实际传输的是纯文本，每一行信息后面有\r\n换行符
    ```
    HTTP/1.1 200 OK                             // 请求状态行
    Content-Type: text/html                     // 响应头，从第二行开始是响应头
    Date: Mon, 23 Dec 2019 06:46:19 GMT         // 响应头
    Connection: keep-alive                      // 响应头
    Transfer-Encoding: chunked                  // 响应头，响应体的传输方式
                                                // 必须的空白换行符，将响应头与响应体分隔
    26                                          // 响应体，当响应体的内容过长的时候会以chunk的形式将内容分段传输
    <html><body> Hello World<body></html>       // 前面一行代表chunk的大小，此行是chunk的内容
    26                                          // 另外一个chunk的大小
    <html><body> Hello World<body></html>       // 另外一个chunk的内容
    0                                           // '0'代表整个响应体内容传输完毕
    ```
    **以chunk的方式传输响应体的时候，是一个不断传输不断接收的过程，每一个chunk传输当前chunk的大小和chunk的内容**
